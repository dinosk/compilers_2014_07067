//
// Generated by JTB 1.3.2 DIT@UoA patched
//

package visitor;
import syntaxtree.*;
import java.util.*;
import java.io.BufferedWriter;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class LivenessVisitor implements GJVisitor<String, String> {
  HashMap<String, ArrayList<Instruction>> methodInstructions;
  ArrayList<Instruction> instructions;
  ArrayList<String> argList;
  String callUse;
  boolean operation;
  boolean labelFirstInstruction;
  String currentLabel;
  ArrayList<String> operationList;
  HashMap<String, HashSet<String>> methodInterferenceMap;
  HashMap<String, HashMap<String, HashSet<String>>> interferenceMap;
  HashMap<String, Integer> spillCosts;
  HashMap<String, Instruction> labelInstructions;
  Integer iCounter;
  ArrayList<String> liveTemps;
  HashMap<String, Stack<String>> spillStack;
  HashMap<String, HashMap<String, String>> registerMap;
  HashMap<String, HashMap<String, ArrayList<String>>> procStats;
  

  public LivenessVisitor(HashMap<String, HashMap<String, ArrayList<String>>> procStats){
    this.iCounter = 0;
    this.procStats = procStats;
    this.liveTemps = new ArrayList<String>();
    this.instructions = new ArrayList<Instruction>();
    this.operation = false;
    this.labelFirstInstruction = false;
    this.operationList = new ArrayList<String>();
    this.labelInstructions = new HashMap<String, Instruction>();
    this.methodInterferenceMap = new HashMap<String, HashSet<String>>();
    this.interferenceMap = new HashMap<String, HashMap<String, HashSet<String>>>();
    this.spillCosts = new HashMap<String, Integer>();
    this.methodInstructions = new HashMap<String, ArrayList<Instruction>>();
    this.argList = new ArrayList<String>();
    
  }

  public void calcRegisterMap(){
    GraphColoring graph = new GraphColoring(trueCopy(interferenceMap), spillCosts, methodInstructions, procStats);
    registerMap = graph.getRegisterMap();
    spillStack = graph.getSpillStack();
  }

  public HashMap<String, HashMap<String, HashSet<String>>> trueCopy(HashMap<String, HashMap<String, HashSet<String>>> original){
    HashMap<String, HashMap<String, HashSet<String>>> copy = new HashMap<String, HashMap<String, HashSet<String>>>();
    for(String firstLevel : original.keySet()){
      copy.put(firstLevel, new HashMap<String, HashSet<String>>());
      for(String secondLevel : original.get(firstLevel).keySet()){
        copy.get(firstLevel).put(secondLevel, new HashSet<String>());
        for(String thirdLevel : original.get(firstLevel).get(secondLevel)){
          copy.get(firstLevel).get(secondLevel).add(thirdLevel);
        }
      }
    }
    return copy;
  } 

  // Functions to return final HashMaps to Main

  public HashMap<String, HashMap<String, String>> getRegisterMap(){
    return registerMap;
  }

  // The SpillStack contains the TEMPS that get spilled for each method
  public HashMap<String, Stack<String>> getSpillStack(){
    return spillStack;
  }

  public HashMap<String, ArrayList<Instruction>> getCFG(){
    return methodInstructions;
  }

  public HashMap<String, HashMap<String, HashSet<String>>> getInterferenceMap(){
    return interferenceMap;
  }

  // LabelInstructions is a Map: LABEL to the corresponding Instruction
  public HashMap<String, Instruction> getLabelInstructions(){
    return labelInstructions;
  }

   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public String visit(NodeList n, String argu) {
      if (n.size() == 1)
         return n.elementAt(0).accept(this,argu);
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeListOptional n, String argu) {
      if ( n.present() ) {
         if (n.size() == 1)
            return n.elementAt(0).accept(this,argu);
         String _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public String visit(NodeOptional n, String argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public String visit(NodeSequence n, String argu) {
      if (n.size() == 1)
         return n.elementAt(0).accept(this,argu);
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeToken n, String argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public String visit(Goal n, String argu) {
      String _ret=null;

      Instruction i;
      Instruction succI;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      methodInstructions.put("MAIN", instructions);
      instructions = new ArrayList<Instruction>();

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      // loop to create CFG
      // if instruction is JUMP or CJUMP put target instruction in successors 
      for(String method : methodInstructions.keySet()){
        for(int j=0; j<methodInstructions.get(method).size(); j++){
          i = methodInstructions.get(method).get(j);
          
          if(j == methodInstructions.get(method).size()-1)  
            succI = null;
          else
            succI = methodInstructions.get(method).get(j+1);

          if(i.getType().equals("JUMP")){
            i.getSucc().add(labelInstructions.get(i.getJumpLabel()));
          }
          else if (i.getType().equals("CJUMP")){
            i.getSucc().add(labelInstructions.get(i.getJumpLabel()));
            if(succI != null)
              i.getSucc().add(succI);
          }
          else
            if(succI != null)
              i.getSucc().add(succI);
        }        
      }
      
      // System.out.println("calculating in and out sets");
      // loop to calculate in and out sets
      for(String method : methodInstructions.keySet()){
        instructions = methodInstructions.get(method);
        
        int changes = 0;
        int reps = 0;
        while(changes != instructions.size()){
          reps++;
          changes = 0;
          for(int j=instructions.size()-1; j>=0; j--){
            i = instructions.get(j);
            HashSet<String> oldIn = new HashSet<String>(i.getIn());
            HashSet<String> oldOut = new HashSet<String>(i.getOut());
            Set<String> intersection = new HashSet<String>(i.getOut());
            intersection.removeAll(i.getDef()); // out - def
            intersection.addAll(i.getUse());  // (out - def) U use
            i.getIn().addAll(intersection);   // in = (out - def) U use
            for(Instruction succ : i.getSucc())
              i.getOut().addAll(succ.getIn());  // out[i] = U in[succ-i]

            if(oldOut.equals(i.getOut()) && oldIn.equals(i.getIn()))
              changes++;
          }
        }
      }

      // loops to calculate the interference map       
      for(String method : methodInstructions.keySet()){
        instructions = methodInstructions.get(method);
        HashSet<String> toAdd;
        interferenceMap.put(method, new HashMap<String, HashSet<String>>());
        i = instructions.get(0);
        Iterator iter = i.getIn().iterator();
        String tempIN;
        while(iter.hasNext()){
          tempIN = String.valueOf(iter.next());
          toAdd = new HashSet<String>(i.getIn());
          toAdd.addAll(new HashSet<String>(i.getOut()));
          toAdd.remove(tempIN);
          if(interferenceMap.get(method).get(tempIN) == null)
            interferenceMap.get(method).put(tempIN, toAdd);
          else
            interferenceMap.get(method).get(tempIN).addAll(toAdd);
        }
        // loop for out sets 
        String temp;
        Iterator instructionIter = instructions.iterator();
        while(instructionIter.hasNext()){
          i = (Instruction) instructionIter.next();
          iter = i.getOut().iterator();
          while(iter.hasNext()){
            temp = String.valueOf(iter.next());
            toAdd = new HashSet<String>(i.getOut());
            toAdd.addAll(new HashSet<String>(i.getIn()));
            toAdd.remove(temp);
            if(interferenceMap.get(method).get(temp) == null)
              interferenceMap.get(method).put(temp, toAdd);
            else
              interferenceMap.get(method).get(temp).addAll(toAdd);
          }
          iter = i.getIn().iterator();
          while(iter.hasNext()){
            temp = String.valueOf(iter.next());
            toAdd = new HashSet<String>(i.getOut());
            toAdd.addAll(new HashSet<String>(i.getIn()));
            toAdd.remove(temp);
            if(interferenceMap.get(method).get(temp) == null)
              interferenceMap.get(method).put(temp, toAdd);
            else
              interferenceMap.get(method).get(temp).addAll(toAdd);
          }
        }
      }

      // printing the final interference maps
      // for(String method2 : interferenceMap.keySet()){
      //   System.out.println(method2+"'s interferenceMap:");
      //   for(String temp2 : interferenceMap.get(method2).keySet())
      //     System.out.println(temp2+": "+interferenceMap.get(method2).get(temp2));
      // }
      // try{System.in.read();}
      // catch(Exception e){}
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public String visit(StmtList n, String argu) {
      return n.f0.accept(this, "label");
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public String visit(Procedure n, String argu) {
      String _ret=null;
      String methodName = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      methodInstructions.put(methodName, instructions);
      instructions = new ArrayList<Instruction>();
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public String visit(Stmt n, String argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> "NOOP"
    */
   public String visit(NoOpStmt n, String argu) {
      Instruction i = new Instruction(iCounter, "NOOP", "NOOP");
      // currentI = i;
      iCounter++;
      instructions.add(i);
      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> "ERROR"
    */
   public String visit(ErrorStmt n, String argu) {
      Instruction i = new Instruction(iCounter, "ERROR", "ERROR");
      // currentI = i;
      iCounter++;
      instructions.add(i);
      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public String visit(CJumpStmt n, String argu) {
      String _ret=null;
      // liveGraph.put(iCounter, null);
      
      n.f0.accept(this, argu);
      String temp = n.f1.accept(this, "use");
      String label = n.f2.accept(this, null);

      Instruction i = new Instruction(iCounter, "CJUMP "+temp+" "+label, "CJUMP");
      i.setJumpLabel(label);
      i.getUse().add(temp);
      // currentI = i;
      iCounter++;
      instructions.add(i);
      
      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public String visit(JumpStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String label = n.f1.accept(this, null);
      
      Instruction i = new Instruction(iCounter, "JUMP "+label, "JUMP");
      i.setJumpLabel(label);
      // currentI = i;
      iCounter++;
      instructions.add(i);

      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }
      
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public String visit(HStoreStmt n, String argu) {
      String _ret=null;
      
      n.f0.accept(this, argu);
      String tempUse = n.f1.accept(this, "use");
      String intLit = n.f2.accept(this, argu);
      String tempUse2 = n.f3.accept(this, "use");

      Instruction i = new Instruction(iCounter, "HSTORE "+tempUse+" "+intLit+" "+tempUse2, "HSTORE");
      // currentI = i;
      // i.getDef().add(tempDef);
      i.getUse().add(tempUse);
      i.getUse().add(tempUse2);
      iCounter++;
      instructions.add(i);

      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }

      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public String visit(HLoadStmt n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String tempDef = n.f1.accept(this, "def");
      String tempUse = n.f2.accept(this, "use");
      String intLit = n.f3.accept(this, argu);

      Instruction i = new Instruction(iCounter, "HLOAD "+tempDef+" "+tempUse+" "+intLit, "HLOAD");
      // currentI = i;
      i.getDef().add(tempDef);
      i.getUse().add(tempUse);
      iCounter++;
      instructions.add(i);

      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }

      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public String visit(MoveStmt n, String argu) {
      String _ret=null;
      
      n.f0.accept(this, argu);
      String tempDef = n.f1.accept(this, "def");
      String exp = n.f2.accept(this, "use");

      Instruction i = new Instruction(iCounter, "MOVE "+tempDef+" "+exp, "MOVE");

      i.getDef().add(tempDef);
      if(exp.contains("CALL")){
        i.getUse().add(callUse);
        for(String arg : argList){
          i.getUse().add(arg);
        }
        argList = new ArrayList<String>();
      }
      else if(operation){
        for(String operand : operationList){
          i.getUse().add(operand);
        }
        operationList = new ArrayList<String>();
        operation = false;
      }
      else if(exp.contains("TEMP")){
        i.getUse().add(exp);
      }

      iCounter++;
      instructions.add(i);

      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }

      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public String visit(PrintStmt n, String argu) {
      String _ret=null;
      
      n.f0.accept(this, argu);
      String simpleExp = n.f1.accept(this, "use");

      Instruction i = new Instruction(iCounter, "PRINT "+simpleExp, "PRINT");
      i.getUse().add(simpleExp);
      iCounter++;
      instructions.add(i);

      if(labelFirstInstruction){
        labelInstructions.put(currentLabel, i);
        labelFirstInstruction = false;
      }

      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public String visit(Exp n, String argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public String visit(StmtExp n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String simpleExp = n.f3.accept(this, "use");
      n.f4.accept(this, argu);

      Instruction i = new Instruction(iCounter, "RETURN "+simpleExp, "RETURN");
      // currentI = i;
      i.getUse().add(simpleExp);
      iCounter++;
      instructions.add(i);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public String visit(Call n, String argu) {
      String _ret=null;
      // Instruction i = new Instruction(iCounter);
      // currentI = i;
      // iCounter++;
      // instructions.add(i);
      n.f0.accept(this, argu);
      String simpleExp = n.f1.accept(this, "use");
      n.f2.accept(this, argu);
      n.f3.accept(this, "CALL"); 

      callUse = simpleExp;

      String args = "";
      for(String arg : argList){
        args+=arg+", ";
      }
      args = args.substring(0, args.length()-2);
      n.f4.accept(this, argu);
      return "CALL "+simpleExp+" ("+args+")";
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public String visit(HAllocate n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String simpleExp = n.f1.accept(this, "use");
      return "HALLOCATE "+simpleExp;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public String visit(BinOp n, String argu) {
      String _ret=null;
      
      String operator = n.f0.accept(this, argu);
      String tempUse1 = n.f1.accept(this, "use");
      String tempUse2 = n.f2.accept(this, "use");
      
      this.operation = true;
      // this.operationList.add(operator);
      this.operationList.add(tempUse1);
      if(tempUse2.contains("TEMP"))
        this.operationList.add(tempUse2);

      return operator+" "+tempUse1+" "+tempUse2;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public String visit(Operator n, String argu) {
      n.f0.accept(this, argu);
      return n.f0.choice.toString();
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public String visit(SimpleExp n, String argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public String visit(Temp n, String argu) {
      String _ret=null;
      n.f0.accept(this, argu);
      String intLit = n.f1.accept(this, argu);
      if(argu != null)
        if(argu.equals("CALL")){
          this.argList.add("TEMP "+intLit); 
        }

      if(spillCosts.get("TEMP "+intLit) != null){
        spillCosts.put("TEMP "+intLit, spillCosts.get("TEMP "+intLit)+1);
      }
      else{
        spillCosts.put("TEMP "+intLit, 1);
      }

      return "TEMP "+intLit;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, String argu) {
      n.f0.accept(this, argu);
      return n.f0.toString();
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Label n, String argu) {
      if(argu != null){
        if(argu.equals("label")){
          labelFirstInstruction = true;
          currentLabel = n.f0.toString();
          labelInstructions.put(n.f0.toString(), null);
        }
      }
      n.f0.accept(this, argu);
      
      return n.f0.toString();
   }

}
